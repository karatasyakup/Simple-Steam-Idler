"use strict";

exports.__esModule = true;
exports.createList = exports.unquote = exports.trimChar = exports.createCharGrabber = void 0;

var _char = require("@bbob/plugin-helper/lib/char");

function CharGrabber(source, options) {
  var cursor = {
    pos: 0,
    len: source.length
  };

  var substrUntilChar = char => {
    var {
      pos
    } = cursor;
    var idx = source.indexOf(char, pos);
    return idx >= 0 ? source.substr(pos, idx - pos) : '';
  };

  var includes = val => source.indexOf(val, cursor.pos) >= 0;

  var hasNext = () => cursor.len > cursor.pos;

  var isLast = () => cursor.pos === cursor.len;

  var skip = function skip(num, silent) {
    if (num === void 0) {
      num = 1;
    }

    cursor.pos += num;

    if (options && options.onSkip && !silent) {
      options.onSkip();
    }
  };

  var rest = () => source.substr(cursor.pos);

  var curr = () => source[cursor.pos];

  var prev = () => {
    var prevPos = cursor.pos - 1;
    return typeof source[prevPos] !== 'undefined' ? source[prevPos] : null;
  };

  var next = () => {
    var nextPos = cursor.pos + 1;
    return nextPos <= source.length - 1 ? source[nextPos] : null;
  };

  var grabWhile = (cond, silent) => {
    var start = 0;

    if (hasNext()) {
      start = cursor.pos;

      while (hasNext() && cond(curr())) {
        skip(1, silent);
      }
    }

    return source.substr(start, cursor.pos - start);
  };
  /**
   * @type {skip}
   */


  this.skip = skip;
  /**
   * @returns {Boolean}
   */

  this.hasNext = hasNext;
  /**
   * @returns {String}
   */

  this.getCurr = curr;
  /**
   * @returns {String}
   */

  this.getRest = rest;
  /**
   * @returns {String}
   */

  this.getNext = next;
  /**
   * @returns {String}
   */

  this.getPrev = prev;
  /**
   * @returns {Boolean}
   */

  this.isLast = isLast;
  /**
   * @returns {Boolean}
   */

  this.includes = includes;
  /**
   * @param {Function} cond
   * @param {Boolean} silent
   * @return {String}
   */

  this.grabWhile = grabWhile;
  /**
   * Grabs rest of string until it find a char
   * @param {String} char
   * @return {String}
   */

  this.substrUntilChar = substrUntilChar;
}
/**
 * Creates a grabber wrapper for source string, that helps to iterate over string char by char
 * @param {String} source
 * @param {Object} options
 * @param {Function} options.onSkip
 * @return CharGrabber
 */


var createCharGrabber = (source, options) => new CharGrabber(source, options);
/**
 * Trims string from start and end by char
 * @example
 *  trimChar('*hello*', '*') ==> 'hello'
 * @param {String} str
 * @param {String} charToRemove
 * @returns {String}
 */


exports.createCharGrabber = createCharGrabber;

var trimChar = (str, charToRemove) => {
  while (str.charAt(0) === charToRemove) {
    // eslint-disable-next-line no-param-reassign
    str = str.substring(1);
  }

  while (str.charAt(str.length - 1) === charToRemove) {
    // eslint-disable-next-line no-param-reassign
    str = str.substring(0, str.length - 1);
  }

  return str;
};
/**
 * Unquotes \" to "
 * @param str
 * @return {String}
 */


exports.trimChar = trimChar;

var unquote = str => str.replace(_char.BACKSLASH + _char.QUOTEMARK, _char.QUOTEMARK);

exports.unquote = unquote;

function NodeList(values) {
  if (values === void 0) {
    values = [];
  }

  var nodes = values;

  var getLast = () => Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== 'undefined' ? nodes[nodes.length - 1] : null;

  var flushLast = () => nodes.length ? nodes.pop() : false;

  var push = value => nodes.push(value);

  var toArray = () => nodes;

  this.push = push;
  this.toArray = toArray;
  this.getLast = getLast;
  this.flushLast = flushLast;
}
/**
 *
 * @param values
 * @return {NodeList}
 */


var createList = function createList(values) {
  if (values === void 0) {
    values = [];
  }

  return new NodeList(values);
};

exports.createList = createList;