"use strict";

exports.__esModule = true;
exports.createList = exports.unquote = exports.trimChar = exports.createCharGrabber = void 0;

var _char2 = require("@bbob/plugin-helper/lib/char");

function CharGrabber(source, options) {
  var cursor = {
    pos: 0,
    len: source.length
  };

  var substrUntilChar = function substrUntilChar(_char) {
    var pos = cursor.pos;
    var idx = source.indexOf(_char, pos);
    return idx >= 0 ? source.substr(pos, idx - pos) : '';
  };

  var includes = function includes(val) {
    return source.indexOf(val, cursor.pos) >= 0;
  };

  var hasNext = function hasNext() {
    return cursor.len > cursor.pos;
  };

  var isLast = function isLast() {
    return cursor.pos === cursor.len;
  };

  var skip = function skip(num, silent) {
    if (num === void 0) {
      num = 1;
    }

    cursor.pos += num;

    if (options && options.onSkip && !silent) {
      options.onSkip();
    }
  };

  var rest = function rest() {
    return source.substr(cursor.pos);
  };

  var curr = function curr() {
    return source[cursor.pos];
  };

  var prev = function prev() {
    var prevPos = cursor.pos - 1;
    return typeof source[prevPos] !== 'undefined' ? source[prevPos] : null;
  };

  var next = function next() {
    var nextPos = cursor.pos + 1;
    return nextPos <= source.length - 1 ? source[nextPos] : null;
  };

  var grabWhile = function grabWhile(cond, silent) {
    var start = 0;

    if (hasNext()) {
      start = cursor.pos;

      while (hasNext() && cond(curr())) {
        skip(1, silent);
      }
    }

    return source.substr(start, cursor.pos - start);
  };
  /**
   * @type {skip}
   */


  this.skip = skip;
  /**
   * @returns {Boolean}
   */

  this.hasNext = hasNext;
  /**
   * @returns {String}
   */

  this.getCurr = curr;
  /**
   * @returns {String}
   */

  this.getRest = rest;
  /**
   * @returns {String}
   */

  this.getNext = next;
  /**
   * @returns {String}
   */

  this.getPrev = prev;
  /**
   * @returns {Boolean}
   */

  this.isLast = isLast;
  /**
   * @returns {Boolean}
   */

  this.includes = includes;
  /**
   * @param {Function} cond
   * @param {Boolean} silent
   * @return {String}
   */

  this.grabWhile = grabWhile;
  /**
   * Grabs rest of string until it find a char
   * @param {String} char
   * @return {String}
   */

  this.substrUntilChar = substrUntilChar;
}
/**
 * Creates a grabber wrapper for source string, that helps to iterate over string char by char
 * @param {String} source
 * @param {Object} options
 * @param {Function} options.onSkip
 * @return CharGrabber
 */


var createCharGrabber = function createCharGrabber(source, options) {
  return new CharGrabber(source, options);
};
/**
 * Trims string from start and end by char
 * @example
 *  trimChar('*hello*', '*') ==> 'hello'
 * @param {String} str
 * @param {String} charToRemove
 * @returns {String}
 */


exports.createCharGrabber = createCharGrabber;

var trimChar = function trimChar(str, charToRemove) {
  while (str.charAt(0) === charToRemove) {
    // eslint-disable-next-line no-param-reassign
    str = str.substring(1);
  }

  while (str.charAt(str.length - 1) === charToRemove) {
    // eslint-disable-next-line no-param-reassign
    str = str.substring(0, str.length - 1);
  }

  return str;
};
/**
 * Unquotes \" to "
 * @param str
 * @return {String}
 */


exports.trimChar = trimChar;

var unquote = function unquote(str) {
  return str.replace(_char2.BACKSLASH + _char2.QUOTEMARK, _char2.QUOTEMARK);
};

exports.unquote = unquote;

function NodeList(values) {
  if (values === void 0) {
    values = [];
  }

  var nodes = values;

  var getLast = function getLast() {
    return Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== 'undefined' ? nodes[nodes.length - 1] : null;
  };

  var flushLast = function flushLast() {
    return nodes.length ? nodes.pop() : false;
  };

  var push = function push(value) {
    return nodes.push(value);
  };

  var toArray = function toArray() {
    return nodes;
  };

  this.push = push;
  this.toArray = toArray;
  this.getLast = getLast;
  this.flushLast = flushLast;
}
/**
 *
 * @param values
 * @return {NodeList}
 */


var createList = function createList(values) {
  if (values === void 0) {
    values = [];
  }

  return new NodeList(values);
};

exports.createList = createList;